create table public.task_steps (
  id uuid not null default extensions.uuid_generate_v4 (),
  task_header_id uuid not null,
  name text not null,
  description text null,
  step_order integer not null default 1,
  created_at timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
  author_id uuid null,
  external_url text null,
  sort_int integer generated by default as identity not null,
  deleted_at timestamp with time zone null,
  deleted_by uuid null,
  is_deleted boolean null default false,
  constraint task_stages_pkey primary key (id),
  constraint unique_order_per_task unique (task_header_id, step_order),
  constraint task_steps_deleted_by_fkey foreign KEY (deleted_by) references app_profiles (id),
  constraint task_stages_author_id_fkey foreign KEY (author_id) references auth.users (id),
  constraint task_steps_task_header_id_fkey foreign KEY (task_header_id) references task_headers (id) on update CASCADE on delete CASCADE,
  constraint task_steps_description_check check ((length(description) <= 2000)),
  constraint valid_name check ((length(name) > 0))
) TABLESPACE pg_default;

create index IF not exists idx_task_stages_header on public.task_steps using btree (task_header_id) TABLESPACE pg_default;

create index IF not exists idx_task_stages_author on public.task_steps using btree (author_id) TABLESPACE pg_default;

create trigger log_task_steps_events
after INSERT
or DELETE
or
update on task_steps for EACH row
execute FUNCTION log_all_events ();