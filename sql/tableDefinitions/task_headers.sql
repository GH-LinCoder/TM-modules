create table public.task_headers (
  id uuid not null default extensions.uuid_generate_v4 (),
  name text not null,
  description text null,
  external_url text null,
  created_at timestamp with time zone not null default (now() AT TIME ZONE 'utc'::text),
  author_id uuid not null,
  sort_int integer generated by default as identity not null,
  default_manager_id uuid null,
  updated_at timestamp with time zone null,
  deleted_at timestamp with time zone null,
  deleted_by uuid null,
  is_deleted boolean null default false,
  constraint task_headers_pkey primary key (id),
  constraint task_headers_name_key unique (name),
  constraint task_headers_default_manager_id_fkey foreign KEY (default_manager_id) references app_profiles (id) on update CASCADE on delete CASCADE,
  constraint task_headers_deleted_by_fkey foreign KEY (deleted_by) references app_profiles (id),
  constraint task_headers_author_id_fkey foreign KEY (author_id) references auth.users (id),
  constraint task_headers_description_check check ((length(description) <= 2000)),
  constraint valid_name check ((length(name) > 0))
) TABLESPACE pg_default;

create index IF not exists idx_task_headers_author on public.task_headers using btree (author_id) TABLESPACE pg_default;

create trigger cascade_name_description
after
update OF name,
description on task_headers for EACH row
execute FUNCTION sync_task_headers_app_profiles ();

create trigger log_task_events
after INSERT
or DELETE
or
update on task_headers for EACH row
execute FUNCTION log_all_events ();

create trigger new_task_header_create_appro
after INSERT on task_headers for EACH row
execute FUNCTION new_task_header_create_appro ();

create trigger new_task_headers_create_steps
after INSERT on task_headers for EACH row
execute FUNCTION new_task_headers_create_steps ();