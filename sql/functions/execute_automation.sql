--Function to handle automations
-- These actions exceed the permissions of the logged-in user
-- This function calls another function to obtain permission or refusal of permission
-- This function returns any refusal to the client (as JSON)
-- OR
-- Calls the function that carries out the automation & returns success or failure message generated by those functions (JSON)
-- This function returns that JSON to the client (either judgement of refusal OR success or failure of changing the db)

CREATE OR REPLACE FUNCTION execute_automation(
  p_auto_petition JSONB,  -- who/where: auth_id, appro_id, task_id, etc.
  p_auto_parameters JSONB        -- what: task_header_id, relationship_type, etc.
  )

RETURNS JSON
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$

DECLARE
  v_automation_id UUID := (p_auto_petition ->> 'automation_id')::UUID;
  v_judgement JSON;
  v_registry_id UUID;
  v_function_name TEXT;
  v_result JSON;
BEGIN
--possibly check validity of parameters are they all ! null? All 30 chars?  Is this worth doing?

-- need to call the function permissions_judge with all the p_params and to store the reply (JSON) in a variable. 
  v_judgement := automations_judge(p_auto_petition);
  
  -- Check if permission was granted
  --if the variable contains { 'result', 'failed' } RETURN the JSON to the client END
   IF (v_judgement ->> 'result') != 'success' THEN
    RETURN jsonb_build_object(
      'status', 'error',
      'message', format('Permission denied: %s', v_judgement)
    );
  END IF;

-- I have update the automations table to include fk to the automations_registry so I hope
-- that the use of the registry will work on the existing automations (there aren't many anyway)

--use the automations.id to find the automation_registry_id, 
SELECT auto_registry_id INTO v_registry_id FROM automations WHERE id = v_automation_id;

  IF v_registry_id IS NULL THEN
    RETURN jsonb_build_object(
      'status', 'error',
      'message', 'Automation registry id not found in automations.id'
    );
  END IF;


              
--Use the registry id to find the name
SELECT name INTO v_function_name FROM automation_registry WHERE id =v_registry_id;

 IF v_function_name IS NULL THEN
    RETURN jsonb_build_object(
      'status', 'error',
      'message', 'Automation function name not found in registry'
    );
  END IF;



--use that function_name as the call to be made to the function that carries out the action
BEGIN
  EXECUTE format('SELECT %I($1)', v_function_name)
    INTO v_result
    USING p_auto_parameters;

    RETURN v_result; --different to v_judgement ?

       -- probably need some kind of error handling 
  EXCEPTION WHEN undefined_function THEN
    RETURN jsonb_build_object(
      'status', 'error',
      'message', 'Automation function not implemented: ' || v_function_name
    );
  
  WHEN OTHERS THEN
    RETURN jsonb_build_object(
      'status', 'error',
      'message', format('Execution failed: %s', SQLERRM)
    );
  END;

END;
$$;